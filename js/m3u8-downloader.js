/**\n * M3U8 下载器 - 用于在浏览器中直接下载HLS/M3U8视频\n * 支持并发下载、进度显示、自动合并\n */\n\nclass M3U8Downloader {\n    constructor(options = {}) {\n        this.maxConcurrent = options.maxConcurrent || 5; // 最大并发下载数\n        this.timeout = options.timeout || 30000; // 单个片段下载超时时间（毫秒）\n        this.retryCount = options.retryCount || 3; // 失败重试次数\n        this.onProgress = options.onProgress || (() => {}); // 进度回调\n        this.onError = options.onError || (() => {}); // 错误回调\n        this.onComplete = options.onComplete || (() => {}); // 完成回调\n    }\n\n    /**\n     * 解析M3U8文件内容，提取所有.ts片段URL\n     */\n    parseM3U8(content, baseUrl) {\n        const lines = content.split('\\n');\n        const segments = [];\n        const baseUrlObj = new URL(baseUrl);\n        const baseDir = baseUrl.substring(0, baseUrl.lastIndexOf('/') + 1);\n\n        for (let line of lines) {\n            line = line.trim();\n            \n            // 跳过注释和空行\n            if (!line || line.startsWith('#')) continue;\n            \n            // 处理URL\n            if (line.endsWith('.ts') || line.includes('.ts?')) {\n                let segmentUrl = line;\n                \n                // 处理相对URL\n                if (!segmentUrl.startsWith('http')) {\n                    if (segmentUrl.startsWith('/')) {\n                        // 绝对路径\n                        segmentUrl = baseUrlObj.protocol + '//' + baseUrlObj.host + segmentUrl;\n                    } else {\n                        // 相对路径\n                        segmentUrl = baseDir + segmentUrl;\n                    }\n                }\n                \n                segments.push(segmentUrl);\n            }\n        }\n\n        return segments;\n    }\n\n    /**\n     * 下载单个片段，支持重试\n     */\n    async downloadSegment(url, retries = this.retryCount) {\n        try {\n            const controller = new AbortController();\n            const timeoutId = setTimeout(() => controller.abort(), this.timeout);\n\n            const response = await fetch(url, {\n                method: 'GET',\n                mode: 'cors',\n                credentials: 'omit',\n                signal: controller.signal\n            });\n\n            clearTimeout(timeoutId);\n\n            if (!response.ok) {\n                throw new Error(`HTTP ${response.status}`);\n            }\n\n            return await response.arrayBuffer();\n        } catch (error) {\n            if (retries > 0) {\n                // 等待一段时间后重试\n                await new Promise(resolve => setTimeout(resolve, 1000));\n                return this.downloadSegment(url, retries - 1);\n            }\n            throw error;\n        }\n    }\n\n    /**\n     * 下载所有片段，支持并发控制\n     */\n    async downloadAllSegments(segments) {\n        const results = new Array(segments.length);\n        let completed = 0;\n        let failed = 0;\n\n        // 创建一个队列来管理并发下载\n        const queue = segments.map((url, index) => ({ url, index }));\n        let queueIndex = 0;\n\n        const downloadWorker = async () => {\n            while (queueIndex < queue.length) {\n                const item = queue[queueIndex++];\n                \n                try {\n                    const data = await this.downloadSegment(item.url);\n                    results[item.index] = data;\n                    completed++;\n                    \n                    // 调用进度回调\n                    this.onProgress({\n                        loaded: completed,\n                        total: segments.length,\n                        percent: Math.round((completed / segments.length) * 100),\n                        speed: this.calculateSpeed(completed, segments.length)\n                    });\n                } catch (error) {\n                    failed++;\n                    console.error(`Failed to download segment ${item.index}:`, error);\n                    this.onError({\n                        index: item.index,\n                        url: item.url,\n                        error: error.message\n                    });\n                }\n            }\n        };\n\n        // 启动并发下载workers\n        const workers = [];\n        for (let i = 0; i < Math.min(this.maxConcurrent, segments.length); i++) {\n            workers.push(downloadWorker());\n        }\n\n        await Promise.all(workers);\n\n        if (failed > 0) {\n            throw new Error(`Failed to download ${failed} segments`);\n        }\n\n        return results;\n    }\n\n    /**\n     * 计算下载速度（简化版）\n     */\n    calculateSpeed(completed, total) {\n        // 这是一个简化的速度计算\n        // 实际应用中应该跟踪时间和字节数\n        return `${completed}/${total}`;\n    }\n\n    /**\n     * 合并所有片段为一个Blob\n     */\n    mergeSegments(segmentArrays) {\n        const totalLength = segmentArrays.reduce((sum, arr) => sum + (arr ? arr.byteLength : 0), 0);\n        const merged = new Uint8Array(totalLength);\n        \n        let offset = 0;\n        for (const arr of segmentArrays) {\n            if (arr) {\n                merged.set(new Uint8Array(arr), offset);\n                offset += arr.byteLength;\n            }\n        }\n\n        return new Blob([merged], { type: 'video/mp2t' });\n    }\n\n    /**\n     * 触发浏览器下载\n     */\n    triggerDownload(blob, filename) {\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = filename;\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n        \n        // 释放内存\n        setTimeout(() => URL.revokeObjectURL(url), 100);\n    }\n\n    /**\n     * 主下载函数\n     */\n    async download(m3u8Url, filename) {\n        try {\n            // 1. 获取M3U8文件内容\n            this.onProgress({ status: '正在获取播放列表...' });\n            const m3u8Response = await fetch(m3u8Url, {\n                mode: 'cors',\n                credentials: 'omit'\n            });\n\n            if (!m3u8Response.ok) {\n                throw new Error(`Failed to fetch M3U8: HTTP ${m3u8Response.status}`);\n            }\n\n            const m3u8Content = await m3u8Response.text();\n\n            // 2. 解析M3U8，获取所有.ts片段URL\n            this.onProgress({ status: '正在解析播放列表...' });\n            const segments = this.parseM3U8(m3u8Content, m3u8Url);\n\n            if (segments.length === 0) {\n                throw new Error('No video segments found in M3U8 file');\n            }\n\n            console.log(`Found ${segments.length} segments`);\n\n            // 3. 下载所有片段\n            this.onProgress({ status: `正在下载 ${segments.length} 个视频片段...` });\n            const segmentArrays = await this.downloadAllSegments(segments);\n\n            // 4. 合并片段\n            this.onProgress({ status: '正在合并视频片段...' });\n            const blob = this.mergeSegments(segmentArrays);\n\n            // 5. 触发下载\n            this.onProgress({ status: '正在生成下载链接...' });\n            this.triggerDownload(blob, filename);\n\n            // 6. 完成\n            this.onComplete({\n                filename: filename,\n                size: blob.size,\n                segments: segments.length\n            });\n\n        } catch (error) {\n            console.error('M3U8 Download Error:', error);\n            this.onError({\n                message: error.message,\n                stack: error.stack\n            });\n            throw error;\n        }\n    }\n}\n\n/**\n * 全局M3U8下载函数\n */\nwindow.downloadM3U8Video = async function(m3u8Url, filename) {\n    // 显示下载对话框\n    const modal = document.getElementById('m3u8DownloadModal');\n    if (!modal) {\n        console.error('M3U8 Download Modal not found');\n        return;\n    }\n\n    modal.classList.remove('hidden');\n    const progressBar = document.getElementById('m3u8ProgressBar');\n    const progressText = document.getElementById('m3u8ProgressText');\n    const downloadStatus = document.getElementById('m3u8DownloadStatus');\n    const closeBtn = document.getElementById('m3u8CloseBtn');\n\n    const downloader = new M3U8Downloader({\n        maxConcurrent: 5,\n        timeout: 30000,\n        retryCount: 3,\n        onProgress: (progress) => {\n            if (progress.percent !== undefined) {\n                progressBar.style.width = progress.percent + '%';\n                progressText.textContent = `${progress.percent}% (${progress.loaded}/${progress.total})`;\n            } else if (progress.status) {\n                downloadStatus.textContent = progress.status;\n            }\n        },\n        onError: (error) => {\n            console.error('Download error:', error);\n            downloadStatus.textContent = `错误: ${error.message || error}`;\n            downloadStatus.style.color = '#ef4444';\n        },\n        onComplete: (info) => {\n            downloadStatus.textContent = `下载完成！文件大小: ${(info.size / 1024 / 1024).toFixed(2)}MB`;\n            downloadStatus.style.color = '#10b981';\n            progressBar.style.width = '100%';\n            progressText.textContent = '100%';\n        }\n    });\n\n    try {\n        await downloader.download(m3u8Url, filename);\n    } catch (error) {\n        console.error('Download failed:', error);\n    }\n};\n"
